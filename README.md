# Лабораторная работа №1

Выполнил: Ступин Тимур Русланович

Группа: P3308

Преподаватель: Пенской Александр Владимирович

---

> [Проект Эйлер](https://projecteuler.net/archives), задача [№5](https://projecteuler.net/problem=5) и [№26](https://projecteuler.net/problem=26)

---

## Проблема №5

- **Название**: Smallest Multiple

- **Описание**: $2520$ is the smallest number that can be divided by each of the numbers from $1$ to $10$ without any remainder.

- **Задание**: What is the smallest positive number that is evenly divisible by all of the numbers from $1$ to $20$ ?

### Идея решения

Фактически задача сводится к тому чтобы найти наименьшее общее кратное (НОК) чисел от 1 до 20. Для этого в отдельном модуле [`math`](/src/fp_lab_1/util/math.clj) я реализовал две вспомогательные функции:

```clj
(defn gcd
  "Функция вычисления НОД двух чисел"
  [a b]
  (if (zero? b)
    a
    (gcd b (mod a b))))
```

```clj
(defn lcm
  "Функция вычисления НОК двух чисел"
  [a b]
  (/ (* a b) (gcd a b)))
```

Есть также и альтернативный способ.

Для того чтобы найти НОК всех чисел от $1$ до $N$ нужно:

- найти все простые числа от $1$ до $N$

- возвести каждое из этих чисел в максимально возможную степень так, чтобы результат возведения не превыщал число $N$

- перемножить все результаты возведения

Я использовал этотт подход в реализации с `map`. Он использует функцию `prime?` которая проверяет число на прототу и также реализована в модуле [`math`](/src/fp_lab_1/util/math.clj):

```clj
(defn prime?
  "Функция проверки числа на простоту"
  [n]
  (cond
    (<= n 1) false
    (= n 2) true
    (even? n) false
    :else (not-any? #(zero? (mod n %)) (range 3 (inc (Math/sqrt n)) 2))))
```

### Монолитная реализация с использованием хвостовой рекурсии

Алгоритм простой:

- переменная `i` и `result` инициализируются `1`

- если `i > n` возращаем `result`

- иначе возвращаемся к началу цикла, присвоив `i` значение `i + 1` а result значение `НОК(result, i)`

Для реализации хвостовой рекурсии используется конструкция `loop` и `recur` так как компилятор Clojure сам по себе не производит эту оптимизацию.


```clj
(defn smallest-multiple [n]
  (loop [i 1 result 1]
    (if (> i n)
      result
      (recur (inc i) (lcm result i)))))
```

[Файл с решением](/src/fp_lab_1/task5/tail_rec.clj)

### Простое рекурсивное решение

Здесь всё предельно просто и прямолинейно:

- если `n = 1` то возвращаем `1`

- иначе возвращаем HOK от `n` и рекурсивного вызова с `n - 1`

```clj
(defn smallest-multiple [n]
  (if (= n 1)
    1
    (lcm n (smallest-multiple (dec n)))))
```

[Файл с решением](/src/fp_lab_1/task5/simple_rec.clj)

### Модульная реализация

Здесь я применил функции `reduce` и `range` для генерации последовательности чисел и применения к ним свёрки через функцию НОК.

Также я использовал макрос `->>` который позволяет привести вложенное применения функций к более читаемому виду.

```clj
(defn smallest-multiple [n]
  (->> (range 1 (inc n))
       (reduce lcm 1)))
```

[Файл с решением](/src/fp_lab_1/task5/module.clj)

### Генерация последовательности через `map`

Здесь я как раз решил применить альтернативный алгоритм решения поставленной задачи. Идея в следующем:

- при помощи range генерируется последовательность чисел от `0` до `n`

- далее при помощи `filter` по `prime?` из неё выбираются только простые числа

- после чего применяется `map`, который применяет к каждому числу функцию `max-power`, которая выполняет описанное в алгоритме возведение в максимальную степень

- наконец производится перемоножение всех чисел при помощи `reduce`

Код описанной функции:

```clj
(defn smallest-multiple [n]
  (->> (range (inc n))
       (filter prime?)
       (map #(max-power % n))
       (reduce * 1)))
```

И также код функции `max-power`:

```clj
(defn max-power
  "Возводит число a в маскимальную степень пока оно меньше числа n"
  [a n]
  (->> (iterate #(* a %) 1)
       (take-while #(< % n))
       (last)))
```

[Файл с решением](/src/fp_lab_1/task5/map.clj)

### Работа со спец синтаксисом циклов

В языке clojure есть функция doseq, позволяющая выполнять определённый действия итеративно, не создавая при этом никаких последовательностей. Она наиболее приближена к определению цикла и обычных языков программирования.

Идея алгоритма в данном случае не меняется, однако теперь накопление результат происходит в переменной result, которая в силу особенностей языка Clojure является атомом `atom`.

```clj
(defn smallest-multiple [n]
  (let [result (atom 1)]
    (doseq [i (range 1 (inc n))]
      (swap! result #(lcm % i)))
    @result))
```

[Файл с решением](/src/fp_lab_1/task5/cycles.clj)

### Работа с бесконечными списками

Тут я фактически применил идею решения из модульной реализации, однако заменил конечный `range` на бесконечный `iterate` а `reduce` на `reductions`. Фактически такая реализация позволяет генерировать бесконечную последовательно из НОК чисел от `1` до `n`. ДЛя получения ответа я просто ограничиваю её 20-ю элементами и беру последний.

```clj
(defn smallest-multiple [n]
  (->> (iterate inc 1)
       (reductions lcm 1)
       (take n)
       (last)))
```

[Файл с решением](/src/fp_lab_1/task5/inf_seq.clj)

## Проблема №26

- **Название**: Reciprocal Cycles

- **Описание**: A unit fraction contains $1$ in the numerator. The decimal representation of the unit fractions with denominators $2$ to $10$ are given:

    ```txt
    1/2 = 0.5
    1/3 = 0.(3)
    1/4 = 0.25
    1/5 = 0.2
    1/6 = 0.1(6)
    1.7 = 0.(142857)
    1/8 = 0.125
    1/9 = 0.(1)
    1/10 = 0.1
    ```

    Where $0.1(6)$ means $0.166666...$ , and has a $1$-digit recurring cycle. It can be seen that $1/7$ has a $6$-digit recurring cycle.

- **Задание**: Find the value of $d < 1000$ for which $1/d$ contains the longest recurring cycle in its decimal fraction part.
